# NeoSQLite v1.2.0 Release Notes

## Overview

This release introduces sophisticated datetime query processing capabilities with enhanced JSON path parsing, specialized datetime indexing, and a three-tier fallback mechanism for optimal performance. The release also includes critical improvements to JSON path handling for nested fields and arrays, making NeoSQLite more robust and feature-complete for complex document structures.

## Highlights

### Enhanced Datetime Query Processing

- **Three-Tier Datetime Processing**: Implements a sophisticated three-tier approach (SQL → Temporary Tables → Python) for handling datetime queries with automatic fallback mechanisms
- **Specialized Datetime Indexing**: New `datetime_field` parameter for `create_index()` to create timezone-normalized datetime indexes using SQLite's `datetime()` function for proper timezone handling
- **Automatic Datetime Detection**: Smart query analysis automatically detects datetime operations and routes them to the specialized processor
- **Timezone Normalization**: Datetime indexes use `datetime(json_extract(...))` for consistent timezone normalization across all datetime comparisons
- **Performance Optimization**: SQL-tier processing with dedicated JSON path support for datetime queries (uses json_* functions instead of jsonb_* for string comparison)

### Advanced JSON Path Support

- **Nested Field Handling**: Comprehensive JSON path parsing for complex nested fields with dot notation (e.g., `user.profile.created_at`)
- **Array Index Access**: Full support for array indexing in field paths (e.g., `tags[0]`, `orders.items[2].name`)
- **Proper Path Conversion**: Automatic conversion of dot notation with array indexing to proper JSON path syntax (e.g., `address.street` → `$.address.street`, `items[0]` → `$.items[0]`)
- **Array Path Handling**: Support for complex nested array access patterns like `orders.items[2].name` and `a.b[0].c[1].d`
- **Path Consistency**: All modules now use centralized `parse_json_path()` utility for consistent path handling across the codebase

### Three-Tier Processing Architecture

- **SQL Tier**: Direct SQL processing using json_* functions for datetime queries to ensure string comparison instead of byte comparison
- **Temporary Table Tier**: Fallback to temporary table processing for complex datetime queries
- **Python Tier**: Pure Python implementation as final fallback for advanced datetime operations
- **Smart Routing**: Automatic detection and routing of datetime queries to appropriate processing tier
- **Performance Monitoring**: Integration with existing force fallback kill switch for benchmarking and debugging

## New Features

### Datetime Query Processing

- **`neosqlite.collection.datetime_query_processor.DateTimeQueryProcessor`**: Complete three-tier datetime query processor with fallback mechanisms
- **`neosqlite.collection.datetime_utils`**: Shared utility module with common datetime patterns and validation functions
- **Automatic Detection**: `_contains_datetime_operations()` method in Cursor class automatically identifies datetime queries
- **Specialized Processing**: `_is_datetime_value()` and `_is_datetime_regex()` methods for accurate datetime pattern recognition
- **Enhanced Performance**: Dedicated datetime processing with optimized SQL generation for datetime comparisons

### Enhanced Index Management

- **Datetime Field Support**: `create_index()` method now accepts `datetime_field: bool = False` parameter for specialized datetime indexing
- **Normalized Datetime Indexes**: New `_create_datetime_index()` method creates timezone-normalized indexes with `datetime(json_extract(...))` 
- **Auto-Detection**: `_is_datetime_indexed_field()` method checks for existing datetime indexes in collection
- **Proper Path Handling**: All FTS index operations now use `parse_json_path()` for consistent field path conversion

### JSON Path Utilities

- **`neosqlite.collection.json_path_utils.parse_json_path()`**: Centralized utility for converting dot notation to JSON path syntax
- **`build_json_extract_expression()`**: Helper for building complete json_extract SQL expressions
- **`build_jsonb_extract_expression()`**: Helper for building complete jsonb_extract SQL expressions
- **Array Support**: Full handling of array indexing in JSON paths (e.g., `field[0]`, `nested.array[2].value`)
- **Backward Compatibility**: Maintains compatibility with existing field references while adding new capabilities

### Query Processing Enhancements

- **Datetime-Aware Operators**: Enhanced `_build_operator_clause()` now accepts `is_datetime_indexed` parameter for proper timezone normalization
- **Index-Aware Processing**: Query engine automatically detects datetime indexes and applies timezone normalization
- **Smart Field Detection**: `_is_datetime_indexed_field()` method identifies datetime-indexed fields in database schema
- **Path Conversion**: All query operations now use proper JSON path conversion for nested field access

### ObjectId Improvements

- **Enhanced Specification**: Updated to follow MongoDB specification more closely (4 bytes timestamp + 5 bytes random + 3 bytes counter vs. previous 4+3+2)
- **Integer Timestamp Support**: ObjectId constructor now accepts integer timestamp values that replace the timestamp part during construction
- **Validation Improvements**: Enhanced validation for integer timestamp values (0 to 0xFFFFFFFF range)
- **Thread Safety**: Proper locking for counter and random bytes generation

## Technical Benefits

- **Performance Optimization**: Three-tier datetime processing provides optimal performance for datetime queries while maintaining accuracy
- **Timezone Handling**: Proper timezone normalization ensures consistent datetime comparisons across different timezones
- **JSON Path Consistency**: Centralized JSON path utilities ensure consistent handling of nested fields and arrays throughout the codebase
- **Backward Compatibility**: All existing functionality preserved while adding new capabilities
- **Robustness**: Enhanced error handling and fallback mechanisms for complex datetime operations
- **Scalability**: Efficient processing of large datasets with datetime queries using SQL optimization
- **Type Safety**: Comprehensive type annotations throughout new datetime processing modules

## Breaking Changes

There are no intentional breaking changes in this release that would break existing application logic. All existing APIs and functionality remain fully compatible with previous versions. The following behavior changes are worth noting:

- **ObjectId Structure**: Updated to MongoDB specification (4+5+3 bytes vs. previous 4+3+2 bytes), but maintains full compatibility with existing ObjectIds
- **Index Creation**: New `datetime_field` parameter in `create_index()` provides backward compatibility (defaults to False)
- **JSON Path Handling**: All JSON path operations are more robust but maintain the same external behavior

## Migration Notes

For existing databases and applications, this release maintains full backward compatibility. New datetime-related functionality is opt-in and only activates when explicitly using datetime queries or datetime indexes.

### For Datetime Queries:
```python
from neosqlite import Connection

# Connect to database
with Connection(":memory:") as conn:
    collection = conn.my_collection
    
    # Create datetime index for timezone normalization
    collection.create_index("created_at", datetime_field=True)
    
    # DateTime queries will now be processed by specialized processor
    # with timezone normalization for consistent comparisons
    results = collection.find({
        "created_at": {
            "$gte": "2023-01-01T00:00:00Z",
            "$lt": "2023-12-31T23:59:59Z"
        }
    })
    
    # Complex nested datetime queries also supported
    nested_results = collection.find({
        "user.profile.created_at": {
            "$gte": "2023-01-01T00:00:00Z"
        }
    })
```

### For Nested Field Access:
```python
# Now fully supports complex nested paths with array indexing
collection.find({"address.street": "Main St"})  # Works as before
collection.find({"orders.items[0].name": "item1"})  # Now properly supported
collection.find({"users[0].profile.age": {"$gte": 18}})  # Complex array access
```

### For ObjectId Usage:
```python
from neosqlite.objectid import ObjectId

# All existing ObjectId usage continues to work
oid = ObjectId()  # Generates new ObjectId as before
oid_from_hex = ObjectId("507f1f77bcf86cd799439011")  # Works as before

# New functionality: Create ObjectId with specific timestamp
import time
timestamp = int(time.time())
custom_oid = ObjectId(timestamp)  # Creates ObjectId with specific timestamp
```

## Installation

```bash
# Standard installation
pip install neosqlite==1.2.0

# For enhanced JSON/JSONB support  
pip install neosqlite[jsonb]==1.2.0

# For memory-constrained processing of large result sets
pip install neosqlite[memory-constrained]==1.2.0

# Install multiple extras
pip install neosqlite[jsonb,memory-constrained]==1.2.0
```

## Notable Examples

### Datetime Indexing Example:
```python
from neosqlite import Connection
import datetime

with Connection(":memory:") as conn:
    collection = conn.events
    
    # Insert documents with datetime fields
    collection.insert_many([
        {"name": "Event 1", "timestamp": "2023-06-15T10:30:00Z"},
        {"name": "Event 2", "timestamp": "2023-07-20T14:45:00Z"},
        {"name": "Event 3", "timestamp": "2023-08-10T09:15:00Z"},
    ])
    
    # Create datetime index with timezone normalization
    collection.create_index("timestamp", datetime_field=True)
    
    # Efficient datetime queries with proper timezone handling
    recent_events = collection.find({
        "timestamp": {
            "$gte": "2023-07-01T00:00:00Z",
            "$lt": "2023-09-01T00:00:00Z"
        }
    })
    
    for event in recent_events:
        print(f"Event: {event['name']} at {event['timestamp']}")
```

### Complex Nested Field Example:
```python
from neosqlite import Connection

with Connection(":memory:") as conn:
    collection = conn.orders
    
    # Documents with complex nested structures and arrays
    collection.insert_many([
        {
            "customer": "John",
            "orders": [
                {"items": [{"name": "laptop", "price": 1000}]},
                {"items": [{"name": "mouse", "price": 25}]}
            ]
        }
    ])
    
    # Efficient queries on nested fields with array access
    expensive_items = collection.find({
        "orders.items[0].price": {"$gte": 500}
    })
    
    # Complex nested path with proper JSON path conversion
    results = collection.find({
        "orders.items.name": "laptop"  # Now properly converted to $.orders.items[*].name
    })
```

This release significantly enhances NeoSQLite's capability to handle complex datetime queries and nested document structures while maintaining the performance and reliability that NeoSQLite is known for. The addition of specialized datetime processing and robust JSON path handling makes NeoSQLite even more suitable for applications requiring sophisticated querying capabilities.
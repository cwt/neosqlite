# NeoSQLite v1.4.0 Release Notes

## Overview

This is a major feature release that introduces the MongoDB `$expr` operator framework with a sophisticated three-tier evaluation architecture (SQL → Temp Tables → Python fallback). NeoSQLite now supports 78% of `$expr` operators (71 operators implemented) with all high-priority operators complete. This release also includes critical bug fixes for FTS5 indexing, pipeline reordering, JSONB performance enhancements, and changestream binary data handling.

**Note**: The `$expr` implementation is still a work in progress (WIP) with 23 medium/low-priority operators remaining. All high-priority operators are complete and production-ready.

## New Features

### MongoDB $expr Operator Framework (WIP)

**Added**: Comprehensive `$expr` operator support with intelligent three-tier evaluation architecture

#### Three-Tier Architecture
- **Tier 1 (SQL)**: Direct SQL conversion for optimal performance
- **Tier 2 (Temp Tables)**: Temporary table evaluation for complex expressions
- **Tier 3 (Python)**: Fallback evaluation for unsupported operators
- **Automatic Tier Selection**: Based on expression complexity scoring
- **Kill Switch**: Force Python evaluation for debugging/benchmarking

#### Implemented Operator Categories (78% Coverage)

**100% Complete Categories:**
- **Comparison Operators** (8 operators): `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`, `$in`, `$nin`
- **Logical Operators** (4 operators): `$and`, `$or`, `$not`, `$nor`
- **Conditional Operators** (3 operators): `$cond`, `$ifNull`, `$switch`

**High Priority Operators (Complete):**
- **Date Arithmetic** (3 operators): `$dateAdd`, `$dateSubtract`, `$dateDiff`
  - Supports: day, hour, minute, second, week, month, year units
  - SQL tier: SQLite `datetime()`/`julianday()` functions
  - Python tier: `datetime`/`timedelta` operations
- **Regex Operations** (2 operators): `$regexFind`, `$regexFindAll`
  - Returns match objects with match, index, captures
  - Supports options: `i` (case-insensitive), `m` (multiline), `s` (dotall)
- **Array Transformation** (3 operators): `$filter`, `$map`, `$reduce`
  - Variable scoping: `$$var`, `$$varIndex`, `$$value`, `$$this`, `$$index`
  - Nested expression evaluation support

**Array Aggregation Operators:**
- `$sum`, `$avg`, `$min`, `$max` - SQL and Python support
- `$slice` - SQL implementation with count and skip parameters

**Arithmetic Operators (80% Coverage):**
- Basic: `$abs`, `$add`, `$ceil`, `$divide`, `$exp`, `$floor`, `$multiply`, `$subtract`
- Advanced: `$log`, `$log10`, `$round`, `$sqrt`, `$trunc`

**Array Operators (60% Coverage):**
- Access: `$arrayElemAt`, `$first`, `$last`, `$indexOfArray`, `$size`
- Manipulation: `$concatArrays`, `$reverseArray`, `$slice`
- Aggregation: `$sum`, `$avg`, `$min`, `$max`

**String Operators (Partial):**
- `$concat`, `$substr`, `$substrBytes`, `$substrCP`, `$strcasecmp`, `$toLower`, `$toUpper`

**Date/Time Operators (Partial):**
- `$dateToString`, `$dateFromString`, `$dayOfMonth`, `$dayOfWeek`, `$dayOfYear`
- `$hour`, `$minute`, `$month`, `$second`, `$week`, `$year`
- `$isoDayOfWeek`, `$isoWeek`, `$isoWeekYear`

**Object Operators (Partial):**
- `$mergeObjects`, `$objectToArray`, `$setField`, `$unsetField`

**Type Operators (Partial):**
- `$type`, `$convert`, `$toDouble`, `$toInt`, `$toString`, `$toBool`, `$toDate`

**Usage Examples:**
```python
# Comparison in aggregation
collection.aggregate([
    {"$match": {"$expr": {"$gt": ["$qty", 100]}}}
])

# Date arithmetic
collection.aggregate([
    {"$match": {"$expr": {
        "$eq": [
            {"$dateDiff": {"startDate": "$start", "endDate": "$end", "unit": "day"}},
            30
        ]
    }}}
])

# Regex operations
collection.aggregate([
    {"$match": {"$expr": {
        "$regexFind": {"input": "$text", "regex": "pattern", "options": "i"}
    }}}
])

# Array transformation
collection.aggregate([
    {"$match": {"$expr": {
        "$gt": [
            {"$size": {"$filter": {"input": "$scores", "as": "s", "cond": {"$gt": ["$$s", 90]}}}},
            0
        ]
    }}}
])

# Complex nested expressions
collection.aggregate([
    {"$match": {"$expr": {
        "$and": [
            {"$gt": ["$price", 100]},
            {"$lt": [
                {"$dateDiff": {"startDate": "$created", "endDate": "$$NOW", "unit": "day"}},
                30
            ]}
        ]
    }}}
])
```

#### Performance Enhancements

**JSONB Support:**
- Auto-detection of SQLite JSONB capabilities
- Function caching for improved performance
- Dynamic function selection based on SQLite version
- Graceful fallback for SQLite < 3.51.0

**Before (v1.3.2)**:
```python
# No $expr support
# Complex queries required workarounds
```

**After (v1.4.0)**:
```python
# Full $expr support with automatic tier selection
collection.find({"$expr": {"$gt": ["$qty", 100]}})  # ✅ SQL tier
collection.find({"$expr": {"$regexFind": {...}}})   # ✅ Python tier
```

## Bug Fixes

### Issue #32: $unwind + $text Search Pipeline Reordering

**The Story**: This bug was discovered through an interesting chain of events:

1. **Initial Discovery**: A benchmark example (`text_search_json_each_benchmark.py`) was producing inconsistent results
2. **Root Cause #1**: The benchmark was creating documents with non-unique `_id` values, causing data overwrites
3. **First Fix**: Fixed the benchmark to use unique `_id` values (changeset 365)
4. **The Rabbit Hole**: After fixing the `_id` issue, the benchmark still failed—revealing a deeper bug
5. **Root Cause #2**: The query optimizer was incorrectly reordering `$match` with `$text` **before** `$unwind`, fundamentally changing the search semantics

**Problem**: `$match` with `$text` incorrectly pushed before `$unwind`, changing search semantics

**Example of the Bug**:
```python
# Intended: Search within unwound array elements
collection.aggregate([
    {"$unwind": "$comments"},           # First: unwind comments array
    {"$match": {"$text": {"$search": "performance"}}}  # Then: search in comments
])

# What NeoSQLite was doing (WRONG):
# 1. $match pushed before $unwind
# 2. Searching in the array field itself, not array elements
# 3. Results: Incorrect or empty
```

**Solution**:
- Disable SQL optimization for `$unwind` + `$text` combinations
- Use temp table fallback to preserve `$text` semantics after `$unwind`
- Fix pipeline reordering logic to maintain correct execution order

### FTS5 Indexing for Nested Arrays

**Problem**: FTS indexes on nested arrays (e.g., "comments.text") only indexed first element

**Solution**:
- Use `json_tree()`/`jsonb_tree()` for full array FTS indexing
- Proper handling of nested array structures
- Complete text search coverage for all array elements

### Temp Table Improvements

**Problem**: Temp table processing missing `_id` column and poor JSONB handling

**Solution**:
- Include `_id` in all temp tables
- Fix JSONB conversion for temp table operations
- Add FTS5 on temp tables with tokenizer detection

### ChangeStream Binary Data Handling

**Problem**: `UnicodeDecodeError` when watching collections with binary data containing non-UTF-8 bytes

**Solution**:
- Proper UTF-8 decoding with error handling in changestream
- Graceful fallback for binary data that can't be decoded
- Support for all BSON binary subtypes

**Before**:
```python
# Inserting binary data with non-UTF-8 bytes
collection.insert_one({"data": Binary(b"\x00\xcc\xfe\xff")})
# Watching changes would raise UnicodeDecodeError
change = next(change_stream)  # ❌ UnicodeDecodeError
```

**After**:
```python
# Binary data handled correctly
collection.insert_one({"data": Binary(b"\x00\xcc\xfe\xff")})
change = next(change_stream)  # ✅ Works correctly
```

### JSONB Detection Fix

**Problem**: Incorrect jsonb_each support detection for SQLite < 3.51.0

**Solution**:
- Fixed version detection logic
- Removed 46 redundant func_prefix assignments
- Cleaner code with better maintainability

## Implementation Details

### Core Changes

**expr_evaluator.py** (~2000 lines):
- SQL conversion for all implemented operators
- Python evaluation fallback
- Three-tier architecture implementation
- Complexity scoring system

**expr_temp_table.py** (~600 lines):
- Tier 2 temporary table support
- TempTableExprEvaluator class (95% test coverage)
- Automatic resource management

**query_helper.py** (~3800 lines):
- Tier selection logic
- Pipeline optimization
- Complexity analysis
- Constraint handling

**cursor.py**:
- $expr query handling
- JSON conversion
- Integration with aggregation pipeline

**jsonb_support.py**:
- Auto-detection of JSONB capabilities
- Function caching
- Dynamic function selection

**changestream.py**:
- UTF-8 decoding with error handling
- Binary data support

### Documentation

**New Files:**
- **`documents/EXPR_IMPLEMENTATION.md`** - Complete implementation guide (~540 lines)
- **`examples/expr_high_priority_demo.py`** - High-priority operators demonstration

**Updated Files:**
- **`README.md`** - $expr usage examples
- **`documents/TODO/IMPLEMENTATION_ROADMAP.md`** - Updated with $expr progress

## Known Limitations

### $expr Implementation (WIP)

As of v1.4.0, the `$expr` implementation is 78% complete. All high-priority operators are implemented and production-ready.

**Missing Operators (23 total):**

**Medium Priority (18 operators):**
- **Set Operations** (7): `$setUnion`, `$setDifference`, `$setEquals`, `$setIsSubset`, `$anyElementTrue`, `$allElementsTrue`
- **Trigonometric** (8): `$sin`, `$cos`, `$tan`, `$asin`, `$acos`, `$atan`, `$atan2`, `$degreesToRadians`
- **Angle Conversion** (3): `$radiansToDegrees`

**Low Priority (16 operators):**
- **Advanced Math** (6): `$pow`, `$ln`, `$mod`, `$rand`, `$sampleRate`, `$stdDevSamp`
- **String** (4): `$indexOfBytes`, `$indexOfCP`, `$regexMatch`, `$split`
- **Type Conversion** (4): `$toLong`, `$toDecimal`, `$toRegex`, `$toObjectId`
- **Variables** (2): `$$ROOT`, `$$CURRENT`

**Workarounds Available:**
- All missing operators gracefully fall back to Python evaluation
- Queries continue to work with reduced performance
- No breaking changes for existing code

### Performance Considerations

1. **Tier 3 (Python) Fallback**: Operators not yet implemented in SQL use Python evaluation (slower but functional)

2. **Complexity Scoring**: Complex expressions may force temp table usage even when some operators support SQL

3. **Regex Performance**: Regex operations always use Python tier (SQLite regex limitations)

## Working Operations

### $expr in find()
```python
# Comparison operators
collection.find({"$expr": {"$gt": ["$qty", 100]}})

# Logical operators
collection.find({"$expr": {"$and": [{"$gt": ["$qty", 100]}, {"$lt": ["$price", 50]}]}})

# Date arithmetic
collection.find({"$expr": {
    "$eq": [
        {"$dateDiff": {"startDate": "$start", "endDate": "$$NOW", "unit": "day"}},
        30
    ]
}})

# Regex operations
collection.find({"$expr": {
    "$regexFind": {"input": "$text", "regex": "pattern", "options": "i"}
}})

# Array operations
collection.find({"$expr": {
    "$gt": [{"$size": "$tags"}, 5]
}})
```

### $expr in Aggregation
```python
# $match with $expr
collection.aggregate([
    {"$match": {"$expr": {"$gt": ["$qty", 100]}}},
    {"$sort": {"$price": -1}}
])

# Complex expressions
collection.aggregate([
    {"$match": {"$expr": {
        "$and": [
            {"$gt": ["$qty", 100]},
            {"$lt": [
                {"$dateDiff": {"startDate": "$created", "endDate": "$$NOW", "unit": "day"}},
                30
            ]}
        ]
    }}}
])

# Array transformation
collection.aggregate([
    {"$match": {"$expr": {
        "$gt": [
            {"$size": {"$filter": {"input": "$scores", "as": "s", "cond": {"$gt": ["$$s", 90]}}}},
            0
        ]
    }}}
])
```

### FTS5 with $unwind
```python
# Text search on unwound arrays (correctly ordered)
collection.aggregate([
    {"$unwind": "$comments"},
    {"$match": {"$text": {"$search": "performance"}}},
    {"$group": {"_id": "$comments.author", "count": {"$sum": 1}}}
])
```

### ChangeStream with Binary Data
```python
# Binary data in watched collections
collection.insert_one({"data": Binary(b"\x00\xcc\xfe\xff", subtype=0)})

# ChangeStream handles binary data correctly
with collection.watch(full_document="updateLookup") as stream:
    change = next(stream)  # ✅ No UnicodeDecodeError
```

## Testing

### New Test Files Added

**$expr Test Suite (327 tests):**
- **test_arithmetic_math_operators.py** - Arithmetic and math operators
- **test_array_operators.py** - Array access and manipulation
- **test_array_aggregation.py** - Array aggregation operators ($sum, $avg, $min, $max)
- **test_comparison_operators.py** - Comparison operators
- **test_conditional_operators.py** - Conditional operators
- **test_date_operators.py** - Date/time operators
- **test_logical_operators.py** - Logical operators
- **test_object_operators.py** - Object operators
- **test_string_operators.py** - String operators
- **test_type_operators.py** - Type operators
- **test_high_priority_operators.py** - Date arithmetic, regex, array transformation
- **test_temp_table_evaluator.py** - Tier 2 evaluation (95% coverage)
- **test_integration.py** - End-to-end integration tests
- **test_error_handling.py** - Error handling and edge cases
- **test_kill_switch.py** - Kill switch functionality
- **test_sql_python_consistency.py** - SQL vs Python consistency verification

**Bug Fix Tests:**
- **test_jsonb_support.py** - JSONB auto-detection and caching
- **test_query_engine_suite.py** - Query engine fixes
- **test_nested_fields_unwind.py** - Nested field unwinding
- **test_text_search_and_logical_operators.py** - FTS5 with logical operators
- **test_changestream.py** - Binary data handling (3 new tests)

### Test Coverage

- **$expr Tests**: 327 tests (all pass)
- **Total Tests**: 1240+ tests
- **Overall Coverage**: 82%
- **TempTableExprEvaluator**: 95% coverage

### Compatibility Testing

- **Backward Compatibility**: All existing 253+ tests still pass
- **SQL vs Python Consistency**: Verified for all implemented operators
- **Kill Switch**: Tested for all new operators
- **Graceful Fallback**: Unsupported operators fall back to Python tier

## Documentation Updates

### Updated Files
- **`README.md`**: $expr usage examples
- **`documents/TODO/IMPLEMENTATION_ROADMAP.md`**: $expr progress tracking
- **`documents/EXPR_IMPLEMENTATION.md`**: Complete implementation guide

### New Files
- **`documents/EXPR_IMPLEMENTATION.md`**: Comprehensive $expr documentation
- **`documents/releases/v1.4.0.md`**: This release note
- **`examples/expr_high_priority_demo.py`**: High-priority operators demo

## Installation

```bash
# Standard installation
pip install neosqlite==1.4.0

# For enhanced JSON/JSONB support
pip install neosqlite[jsonb]==1.4.0

# For memory-constrained processing of large result sets
pip install neosqlite[memory-constrained]==1.4.0

# Install multiple extras
pip install neosqlite[jsonb,memory-constrained]==1.4.0
```

## Upgrade Notes

### From v1.3.2

This release adds significant new functionality while maintaining full backward compatibility:

**New capabilities in v1.4.0:**
- `$expr` operator framework (78% coverage, all high-priority complete)
- Three-tier evaluation architecture (SQL → Temp Tables → Python)
- Date arithmetic operators ($dateAdd, $dateSubtract, $dateDiff)
- Regex operations ($regexFind, $regexFindAll)
- Array transformation ($filter, $map, $reduce)
- Array aggregation ($sum, $avg, $min, $max)
- JSONB auto-detection and caching
- Fixed $unwind + $text pipeline reordering
- Fixed FTS5 indexing for nested arrays
- Fixed ChangeStream binary data handling

**$expr functionality** is production-ready for implemented operators with graceful fallback for missing ones.

### Breaking Changes

**None** - This release maintains full backward compatibility with v1.3.2.

### Migration Notes

- Existing code continues to work unchanged
- New $expr operators available immediately
- JSONB enhancements are automatic (no configuration needed)
- FTS5 and pipeline fixes are transparent

## Compatibility

- **Backward Compatible**: All existing code continues to work unchanged
- **API Stability**: Full PyMongo API compatibility maintained
- **$expr Coverage**: 78% of operators implemented (all high-priority complete)
- **Graceful Fallback**: Missing operators use Python evaluation

